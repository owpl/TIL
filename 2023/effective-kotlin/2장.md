## 2장 가독성

`목표` 가독성이 좋게 프로그램을 설계하라. 간결함은 가독성의 부수효과일뿐.

### Item.11 가독성을 목표로 설계하라.

가독성은 사람에 따라 다르게 느낄 수 있는데, 일반적으로 경험 / 인식에 대한 과학으로 만들어진 어느정도의 규칙이 있다.

```kotlin
// case 1
if(person != null && person.isAdult) {
    
} else {
    
}

// case 2 
person?.takeIf {it.isAdult()}
    ?.let() 
    ?: ()
```

코틀린 경험이 많은 개발자라면 case2 를 쉽게 읽을 수 있겠으나, 숙련된 개발자만을 위한 코드는 좋은 코드가 아님.
또한 Library 를 잘못 이해할 경우 버그가 생기기 쉬운 코드임. (`let` this 를 리턴하냐 / 실제 값을 리턴하냐)

`결론` 인지부하를 줄이는 방향으로 코드를 작성해라.

다만, 극단적으로 `let 을 사용하지마 !` 라고 생각해선 안됨.
가독성을 일부 해치더라도, 지불할만한 가치가 있다면 사용해도 좋음 (가치가 있는가? 는 팀 혹은 개인이 결정해야함.)

> 컨벤션을 지켜라.

### Item.12 연산자 Overload 는 의미에 맞게 사용하라.

kotlin 에서는 연산자를 overload 할 수 있다.  
다만, 용도에 맞게 overload 를 해라.   

> Not 에 factorial 을 구현하는건 옳지 않음

조금이라도 애매할 경우, infix 함수 혹은 확장 함수를 사용하라. (DSL 은 예외)

### Item. 13 Unit? 을 리턴하지 마라.

Unit? 을 사용해서 verify 로직을 구현해선 안된다.  
Kotlin Code 를 이해하기도 어렵고, 차라리 boolean 으로 verify 를 구현하라.


### Item. 14 변수 타입이 명확하지 않은 경우, 확실하게 지정하라.

가독성 향상을 위해, 변수 타입이 명확하지 않은 경우 타입을 지정하라.

> 결국 상황에 맞게 인듯. 

### Item. 15 리시버를 명시적으로 참조하라.

스코프 내부에 둘 이상의 리시버가 있는 경우, 명시적으로 리시버를 참조하는게 좋다.

> apply / with / run 같이 리시버를 넘기는 경우, 특히 This 를 명시하는게 좋다.

context 가 넘어가는 object 인지, 함수가 호출되는 object 인지 헷갈릴 수 있으므로, 짧게 적을 수 있다는 이유만으로, 리시버를 제거하지 말아라.


### Item.16 프로퍼티는 동작이 아니라 상태를 나타내야한다.

프로퍼티는 필드가 필요 없으며, 개념적으로는 getter / setter (val 의 경우 getter) 를 의미한다.
따라서, 상속을 통한 override 를 사용할 수 있다.

같은 매커니즘으로 val / var property 에 프로퍼티 위임을 사용할 수 있다.
```text
by keyword 를 통해 accessor 위임 가능.
```

다만, property 를 동작 처럼 사용할 수 있다고 해서, 완전히 대체하는건 좋지 않다.

원칙적으로 상태를 나타내거 설정하기 위한 용도로만 사용하는게 좋다.

> getter / setter 에 로직을 포함시킬 것인가 ? 에 대한 이야기

### Item.17 이름있는 아규먼트를 사용하라.

- 디폴트 아규먼트의 경우
- 같은 타입의 파라미터가 많은 경우 
  - bookRepository.findBy(peopleId) 
  - 위같은 잘못된 Id 를 넘기는걸 방지할 수 있음
- 함수 타입의 파라미터가 있는 경우

이름 있는 argument 를 사용하라.

```kotlin
listOf<String>().joinToString { "" }
listOf<String>().joinToString("")
```

재밌는 예시. default param 을 사용했다면 조금 더 빨리 문제 파악을 할 수 있다.

### Item. 18 컨벤션을 지켜라.

코딩 컨벤션을 지켜라.